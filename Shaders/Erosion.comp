#version 460 core

layout (local_size_x = 16, local_size_y = 16) in;

struct Output {
    vec4 position;
    vec4 normal;
    uint biomeIDs[3];
    float biomeWeight[3];
    float waterAmount;
    float sedimentAmount;
};

layout (std430, binding = 0) buffer Inputs {
    Output inputs[];
};

layout (std430, binding = 1) buffer Outputs {
    int outputs[];
};



uniform int gridSize;
uniform int dropletsPerPos;
uniform float erosionRate = 4.5; // Jak moc se terén eroduje
uniform float depositionRate = 2.2; // Jak moc se sediment usazuje
uniform int numDroplets = 50000; // Počet kapek vody
uniform float inertia = 0.05;
uniform float sedimentCapacityFactor = 4.0;
uniform float minSedimentCapacity = 0.01;
uniform float erodeSpeed = 2.0;
uniform float depositSpeed = 0.5;
uniform float gravity = 9.8;
uniform float initialWaterVolume = 10.0;
uniform float initialSpeed = 2.0;
uniform int dropletIdx;
#define BRUSH_R 3
#define BRUSHPREC (1024 * 16)
uniform int brush_weights[BRUSH_R + 1 + BRUSH_R][BRUSH_R + 1 + BRUSH_R];
uniform float brush[] = {
      0.0f, 0.0f, 0.1f, 0.2f, 0.3f, 0.2f, 0.1f, 0.0f, 0.0f,
      0.0f, 0.2f, 0.4f, 0.6f, 0.7f, 0.6f, 0.4f, 0.2f, 0.0f,
      0.1f, 0.4f, 0.7f, 0.9f, 1.0f, 0.9f, 0.7f, 0.4f, 0.1f,
      0.2f, 0.6f, 0.9f, 1.0f, 1.0f, 1.0f, 0.9f, 0.6f, 0.2f,
      0.3f, 0.7f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 0.7f, 0.3f,
      0.2f, 0.6f, 0.9f, 1.0f, 1.0f, 1.0f, 0.9f, 0.6f, 0.2f,
      0.1f, 0.4f, 0.7f, 0.9f, 1.0f, 0.9f, 0.7f, 0.4f, 0.1f,
      0.0f, 0.2f, 0.4f, 0.6f, 0.7f, 0.6f, 0.4f, 0.2f, 0.0f,
      0.0f, 0.0f, 0.1f, 0.2f, 0.3f, 0.2f, 0.1f, 0.0f, 0.0f,
    };

vec2 hash(vec2 p) {
    vec2 offsetA = vec2(127.1, 311.7);
    vec2 offsetB = vec2(269.5, 183.3) * 2.0;

    return fract(sin(vec2(
        dot(p, offsetA),
        dot(p, offsetB)
    )) * 43758.5453);
}

// Vraci vysku v danem miste s interpolaci
float CalculateHeightAndGradient (vec2 pos, out vec2 gradient) {
    int coordX = int(pos.x);
    int coordY = int(pos.y);

    float x = fract(pos.x);
    float y = fract(pos.y);

    int nodeIndexNW = coordY * gridSize + coordX;
    bool has_next_x = coordX + 1 < gridSize;
    bool has_next_y = coordY + 1 < gridSize;

    float heightNW = inputs[nodeIndexNW].position.y;
    float heightNE = has_next_x ? inputs[nodeIndexNW + 1].position.y : heightNW;
    float heightSW = has_next_y ? inputs[nodeIndexNW + gridSize].position.y : heightNW;
    float heightSE = has_next_x && has_next_y ? inputs[nodeIndexNW + gridSize + 1].position.y : heightNW;

    // Calculate droplet's direction of flow with bilinear interpolation of height difference along the edges
    float gradientX = (heightNE - heightNW) * (1 - y) + (heightSE - heightSW) * y;
    float gradientY = (heightSW - heightNW) * (1 - x) + (heightSE - heightNE) * x;

    // Calculate height with bilinear interpolation of the heights of the nodes of the cell
    float height = heightNW * (1 - x) * (1 - y) + heightNE * x * (1 - y) + heightSW * (1 - x) * y + heightSE * x * y;
    gradient = vec2(gradientX, gradientY);

    return height;
}

void main() {
    uint x = gl_GlobalInvocationID.x;
    uint y = gl_GlobalInvocationID.y;
    if (x >= gridSize || y >= gridSize) return;


    vec2 chunkPos = vec2(x,y);
    vec2 chunkOffset = hash(vec2(x + dropletIdx, y + dropletIdx));
    vec2 dropletPos = chunkPos + chunkOffset;
    
    float speed = initialSpeed;
    float water = initialWaterVolume;

    float sediment = 0.0;  // Kolik sedimentu kapka nese
    vec2 direction = vec2(0.0);

    for (int i = 0; i < 30; i++) {
        if(water <= 0.01 || speed <= 0.01) break;
        vec2 gradient;
        vec2 temp;
        float prevHeight = CalculateHeightAndGradient(dropletPos, gradient);
        vec2 nextDirection = direction * inertia - gradient * (1.0 - inertia);
        if (length(nextDirection) < 0.0001) break;
        //else nextDirection = normalize(nextDirection);
    
        vec2 nextPos = dropletPos + nextDirection * 0.5;
        if (nextPos.x < 0.0 || nextPos.x >= gridSize - 1 || nextPos.y < 0.0 || nextPos.y >= gridSize - 1)
            break;

        float newHeight = CalculateHeightAndGradient(nextPos, temp);
        float deltaHeight = newHeight - prevHeight;

        float capacity = max(-deltaHeight * speed * water * sedimentCapacityFactor, minSedimentCapacity);

    
        if (sediment > capacity || deltaHeight > 0.0) {
            float amountToDeposit = 0.0;
            if (deltaHeight > 0.0) {
                amountToDeposit = min(deltaHeight, sediment);
            } else {
                amountToDeposit = (sediment - capacity) * depositSpeed;
            }

            if (amountToDeposit > 0.0) {
                ivec2 cell = ivec2(floor(dropletPos));
                vec2 offset = fract(dropletPos);

                uint indexNW = uint(cell.y) * gridSize + uint(cell.x);
                uint indexNE = indexNW + 1;
                uint indexSW = indexNW + gridSize;
                uint indexSE = indexSW + 1;

                float wNW = (1.0 - offset.x) * (1.0 - offset.y);
                float wNE = offset.x * (1.0 - offset.y);
                float wSW = (1.0 - offset.x) * offset.y;
                float wSE = offset.x * offset.y;
                uint idx = uint(dropletPos.y) * gridSize + uint(dropletPos.x);
                atomicAdd(outputs[indexNW], int(amountToDeposit * wNW * BRUSHPREC));
                atomicAdd(outputs[indexSW], int(amountToDeposit * wSW * BRUSHPREC));
                atomicAdd(outputs[indexNE], int(amountToDeposit * wNE * BRUSHPREC));
                atomicAdd(outputs[indexSE], int(amountToDeposit * wSE * BRUSHPREC));
                sediment -= amountToDeposit;
            }

        } else {
            float slope = length(temp); // velikost gradientu

            float erosionFromCapacity = (capacity - sediment) * erodeSpeed;
            float rawErosion = erosionFromCapacity * slope;

            float amountToErode = min(rawErosion, -deltaHeight);

            if (amountToErode > 0.0) {
                uint idx = uint(dropletPos.y) * gridSize + uint(dropletPos.x);

                // Celkový součet vah v brushi je 81 (ověř si to případně)
                const float brushSum = 49.6;

                for (int offy = -BRUSH_R; offy <= BRUSH_R; offy++) {
                    for (int offx = -BRUSH_R; offx <= BRUSH_R; offx++) {
                        int bx = offx + BRUSH_R;
                        int by = offy + BRUSH_R;
                        float weight = brush[by * (BRUSH_R * 2 + 1) + bx];

                        int gx = int(x) + offx;
                        int gy = int(y) + offy;

                        if (gx >= 0 && gx < gridSize && gy >= 0 && gy < gridSize) {
                            uint i = uint(gy) * gridSize + uint(gx);

                            // Normalizovaná eroze podle váhy v brushe
                            int erosionAmount = -int(amountToErode * (weight / brushSum) * BRUSHPREC * erosionRate);
                            atomicAdd(outputs[i], erosionAmount);
                        }
                    }
                }

                // sediment zůstává stejný, protože jsme ho rozdistribuovali
                sediment += amountToErode;
            }


        }

        // Update pozice a smeru
        direction = nextDirection;
        dropletPos = nextPos;
        prevHeight = newHeight;
        speed = sqrt(speed * speed + deltaHeight * gravity);
        water *= (1.0 - 0.005);
    }
}